<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sparta Documentation</title>
    <link>/</link>
    <description>Recent content on Sparta Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Mar 2016 21:07:13 +0100</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Walkthrough</title>
      <link>/sample_service/step1/</link>
      <pubDate>Tue, 03 Oct 2017 07:15:40 +0000</pubDate>
      
      <guid>/sample_service/step1/</guid>
      <description>Sparta is a framework for developing and deploying go based AWS Lambda-backed microservices. To help understand what that means we&amp;rsquo;ll begin with a &amp;ldquo;Hello World&amp;rdquo; lambda function and eventually deploy that to AWS. Note that we&amp;rsquo;re not going to handle all error cases to keep the example code to a minimum.
Documentation Updates Please be aware that running Lambda functions may incur costs. Be sure to decommission Sparta stacks after you are finished using them (via the delete command line option) to avoid unwanted charges.</description>
    </item>
    
    <item>
      <title>CloudFormation</title>
      <link>/reference/eventsources/cloudformation/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/cloudformation/</guid>
      <description>NOT YET IMPLEMENTED TODO: CloudFormation source documentation
  </description>
    </item>
    
    <item>
      <title>CloudWatch Events</title>
      <link>/reference/eventsources/cloudwatchevents/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/cloudwatchevents/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to different types of CloudWatch Events. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we&amp;rsquo;re supposed to write a simple &amp;ldquo;HelloWorld&amp;rdquo; CloudWatch event function that has two requirements:
 Run every 5 minutes to provide a heartbeat notification to our alerting system via a logfile entry Log EC2-related events for later processing  Getting Started The lambda function is relatively small: func echoCloudWatchEvent(w http.</description>
    </item>
    
    <item>
      <title>CloudWatch Logs</title>
      <link>/reference/eventsources/cloudwatchlogs/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/cloudwatchlogs/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to CloudWatch Logs. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we&amp;rsquo;re supposed to write a simple &amp;ldquo;HelloWorld&amp;rdquo; CloudWatch Logs function that should be triggered in response to any log message issued to a specific Log Group.
Getting Started Our lambda function is relatively short:</description>
    </item>
    
    <item>
      <title>Cognito</title>
      <link>/reference/eventsources/cognito/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/cognito/</guid>
      <description>NOT YET IMPLEMENTED
TODO: Cognito source documentation</description>
    </item>
    
    <item>
      <title>Command Line Options</title>
      <link>/reference/application/commandline/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/commandline/</guid>
      <description>Introduction Sparta provides a Main function that transforms a set of lambda functions into an application. This function should be called from your application&amp;rsquo;s package main as in:
var lambdaFunctions []*sparta.LambdaAWSInfo lambdaFunctions = append(lambdaFunctions, lambdaFn) err := sparta.Main(&amp;#34;SpartaHelloWorld&amp;#34;, fmt.Sprintf(&amp;#34;Test HelloWorld resource command&amp;#34;), lambdaFunctions, nil, nil) A compiled application provides several command line options which are available by providing the -h/--help option as in:
$ go run main.go --help Simple Sparta application that demonstrates core functionality Usage: main [command] Available Commands: delete Delete service describe Describe service execute Execute explore Interactively explore service help Help about any command provision Provision service version Sparta framework version Flags: -f, --format string Log format [text, json] (default &amp;#34;text&amp;#34;) -h, --help help for main --ldflags string Go linker string definition flags (https://golang.</description>
    </item>
    
    <item>
      <title>Custom Application Commands</title>
      <link>/reference/application/custom_commands/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/custom_commands/</guid>
      <description>Introduction In addition to custom flags, an application may register completely new commands. For example, to support alternative topologies or integrated automated acceptance tests as part of a CI/CD pipeline.
To register a custom command, define a new cobra.Command and add it to the sparta.CommandLineOptions.Root command value. Ensure you use the xxxxE Cobra functions so that errors can be properly propagated.
httpServerCommand := &amp;amp;cobra.Command{ Use: &amp;#34;httpServer&amp;#34;, Short: &amp;#34;Sample HelloWorld HTTP server&amp;#34;, Long: `Sample HelloWorld HTTP server that binds to port: ` + HTTPServerPort, RunE: func(cmd *cobra.</description>
    </item>
    
    <item>
      <title>Custom Flags</title>
      <link>/reference/application/custom_flags/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/custom_flags/</guid>
      <description>Introduction Some commands (eg: provision) may require additional options. For instance, your application&amp;rsquo;s provision logic may require VPC subnets or EC2 SSH Key Names.
The default Sparta command line option flags may be extended and validated by building on the exposed Cobra command objects.
Adding Flags To add a flag, use one of the pflag functions to register your custom flag with one of the standard CommandLineOption values.
For example:</description>
    </item>
    
    <item>
      <title>Custom Resources</title>
      <link>/reference/custom_resources/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/custom_resources/</guid>
      <description>Introduction In some circumstances your service may need to provision or access resources that fall outside the standard workflow. In this case you can use CloudFormation Lambda-backed CustomResources to create or access resources during your CloudFormation stack&amp;rsquo;s lifecycle.
Sparta provides unchecked access to the CloudFormation resource lifecycle via the RequireCustomResource function. This function registers a user-supplied CustomResourceFunction with the larger CloudFormation resource lifecycle.
In this section we&amp;rsquo;ll walk through a sample user-defined custom resource and discuss how a custom resource&amp;rsquo;s outputs can be propagated to an application-level Sparta lambda function.</description>
    </item>
    
    <item>
      <title>Discovery Service</title>
      <link>/reference/discovery/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/discovery/</guid>
      <description>Introduction The ability to provision dynamic infrastructure (see also the SES Event Source Example) as part of a Sparta application creates a need to discover those resources at lambda execution time.
Sparta exposes this functionality via sparta.Discover. This function returns information about the current stack (eg, name, region, ID) as well as metadata about the immediate dependencies of the calling go lambda function.
The following sections walk through provisioning a S3 bucket, declaring an explicit dependency on that resource, and then discovering the resource at lambda execution time.</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>/reference/docker/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/docker/</guid>
      <description>Introduction Document SpartaGrafana project.</description>
    </item>
    
    <item>
      <title>Dynamic Infrastructure</title>
      <link>/reference/dynamic_infrastructure/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/dynamic_infrastructure/</guid>
      <description>Introduction In addition to provisioning AWS Lambda functions, Sparta supports the creation of other CloudFormation Resources. This enables a service to move towards immutable infrastructure, where the service and its infrastructure requirements are treated as a logical unit.
For instance, consider the case where two developers are working in the same AWS account.
 Developer 1 is working on analyzing text documents.  Their lambda code is triggered in response to uploading sample text documents to S3.</description>
    </item>
    
    <item>
      <title>DynamoDB</title>
      <link>/reference/eventsources/dynamodb/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/dynamodb/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to DynamoDB stream events. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we&amp;rsquo;re given a DynamoDB stream. See below for details on how to create the stream. We&amp;rsquo;ve been asked to write a lambda function that logs when operations are performed to the table so that we can perform offline analysis.</description>
    </item>
    
    <item>
      <title>Echo</title>
      <link>/reference/apigateway/example1/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/example1/</guid>
      <description>To start, we&amp;rsquo;ll create a HTTPS accessible lambda function that simply echoes back the contents of the Lambda event. The source for this is the SpartaApplication.
For reference, the echoS3Event function is below.
func echoS3Event(w http.ResponseWriter, r *http.Request) { logger, _ := r.Context().Value(sparta.ContextKeyLogger).(*logrus.Logger) lambdaContext, _ := r.Context().Value(sparta.ContextKeyLambdaContext).(*sparta.LambdaContext) decoder := json.NewDecoder(r.Body) defer r.Body.Close() var jsonMessage json.RawMessage err := decoder.Decode(&amp;amp;jsonMessage) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } logger.WithFields(logrus.Fields{ &amp;#34;RequestID&amp;#34;: lambdaContext.</description>
    </item>
    
    <item>
      <title>Event Sources - Kinesis</title>
      <link>/reference/eventsources/kinesis/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/kinesis/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to Amazon Kinesis streams. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal The goal of this example is to provision a Sparta lambda function that logs Amazon Kinesis events to CloudWatch logs.
Getting Started We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.</description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>/reference/faq/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/faq/</guid>
      <description>Development How do I setup AWS SDK credentials and region? Sparta relies on standard AWS SDK configuration settings. See the official documentation for more information.
During development, configuration is typically done through environment variables:
 AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_REGION  What are the Minimum set of privileges needed for an account to use Sparta? The absolute minimum set of privileges an account needs is the following IAM Policy:
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;Stmt1505975332000&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;cloudformation:DescribeStacks&amp;#34;, &amp;#34;cloudformation:CreateStack&amp;#34;, &amp;#34;cloudformation:CreateChangeSet&amp;#34;, &amp;#34;cloudformation:DescribeChangeSet&amp;#34;, &amp;#34;cloudformation:ExecuteChangeSet&amp;#34;, &amp;#34;cloudformation:DeleteChangeSet&amp;#34;, &amp;#34;cloudformation:DeleteStack&amp;#34;, &amp;#34;iam:GetRole&amp;#34;, &amp;#34;iam:DeleteRole&amp;#34;, &amp;#34;iam:DeleteRolePolicy&amp;#34;, &amp;#34;iam:PutRolePolicy&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;*&amp;#34; ] }, { &amp;#34;Sid&amp;#34;: &amp;#34;Stmt1505975332000&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;s3:PutObject&amp;#34;, &amp;#34;s3:GetBucketVersioning&amp;#34;, &amp;#34;s3:DeleteObject&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::PROVISION_TARGET_BUCKETNAME&amp;#34; ] } ] } This set of privileges should be sufficient to deploy a Sparta application similar to SpartaHelloWorld.</description>
    </item>
    
    <item>
      <title>Hybrid Topologies</title>
      <link>/reference/hybrid_topologies/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/hybrid_topologies/</guid>
      <description>Introduction At a broad level, AWS Lambda represents a new level of compute abstraction for services. Developers don&amp;rsquo;t immediately concern themselves with HA topologies, configuration management, capacity planning, or many of the other areas traditionally handled by operations. These are handled by the vendor supplied execution environment.
However, Lambda is a relatively new technology and is not ideally suited to certain types of tasks. For example, given the current Lambda limits, the following task types might better be handled by &amp;ldquo;legacy&amp;rdquo; AWS services:</description>
    </item>
    
    <item>
      <title>Limitations</title>
      <link>/reference/limitations/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/limitations/</guid>
      <description>Sparta Limitations  go isn&amp;rsquo;t officially supported by AWS (yet)  But, you can vote to make golang officially supported. Because of this, for the default NodeJS proxying is a per-container initialization cost of:  Copying the embedded binary to /tmp Changing the binary permissions Launching it from the new location See the AWS Forum for more background  Depending on container reuse, this initialization penalty (~700ms) may prove burdensome.</description>
    </item>
    
    <item>
      <title>Local Testing</title>
      <link>/reference/local_testing/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/local_testing/</guid>
      <description>While developing Sparta lambda functions it may be useful to test them locally without needing to provision each new code change. Sparta supports localhost testing in two different ways:
 The explore command line option httptest.NewServer for go test style testing  Example For this example, let&amp;rsquo;s define a simple Sparta application:
package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;github.com/Sirupsen/logrus&amp;#34; sparta &amp;#34;github.com/mweagle/Sparta&amp;#34; ) //////////////////////////////////////////////////////////////////////////////// // Hello world event handler // func helloWorld(w http.</description>
    </item>
    
    <item>
      <title>Managing Environments</title>
      <link>/reference/application/environments/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/environments/</guid>
      <description>Introduction It&amp;rsquo;s common for a single Sparta application to target multiple environments. For example:
 Development Staging Production  Each environment is largely similar, but the application may need slightly different configuration in each context.
To support this, Sparta uses Go&amp;rsquo;s conditional compliation support to ensure that configuration information is validated at build time. Conditional compilation is supported via the --tags/-t command line argument.
This example will work through the SpartaConfig sample.</description>
    </item>
    
    <item>
      <title>Profiling</title>
      <link>/reference/profiling/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/profiling/</guid>
      <description>Introduction One of Lambda&amp;rsquo;s biggest strengths, its ability to automatically scale across ephemeral containers in response to increased load, also creates one of its biggest problems: observability. The traditional set of tools used to identify performance bottlenecks are no longer valid, as there is no host into which one can SSH and interactively interrogate. Identifying performance bottlenecks is even more significant due to the Lambda pricing model, where idle time often directly translates into increased costs.</description>
    </item>
    
    <item>
      <title>Request Context</title>
      <link>/reference/apigateway/example3/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/example3/</guid>
      <description>This example demonstrates how to use the Context struct provided as part of the APIGatewayLambdaJSONEvent event. The SpartaGeoIP service will return Geo information based on the inbound request&amp;rsquo;s IP address.
Define the Lambda Function Our function will examine the inbound request, lookup the user&amp;rsquo;s IP address in the GeoLite2 Database and return any information to the client.
As this function is only expected to be invoked from the API Gateway, we&amp;rsquo;ll unmarshall the inbound event:</description>
    </item>
    
    <item>
      <title>S3</title>
      <link>/reference/eventsources/s3/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/s3/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to S3 events. This overview is based on the SpartaImager sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume we have an S3 bucket that stores images. You&amp;rsquo;ve been asked to write a service that creates a duplicate image that includes a characteristic stamp overlay and store it in the same S3 bucket.</description>
    </item>
    
    <item>
      <title>SES</title>
      <link>/reference/eventsources/ses/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/ses/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to inbound email. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we have already verified our email domain with AWS. This allows our domain&amp;rsquo;s email to be handled by SES.
We&amp;rsquo;ve been asked to write a lambda function that logs inbound messages, including the metadata associated with the message body itself.</description>
    </item>
    
    <item>
      <title>SNS</title>
      <link>/reference/eventsources/sns/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/sns/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to SNS events. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we have an SNS topic that broadcasts notifications. We&amp;rsquo;ve been asked to write a lambda function that logs the Subject and Message text to CloudWatch logs for later processing.
Getting Started We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.</description>
    </item>
    
    <item>
      <title>Slack SlashCommand</title>
      <link>/reference/apigateway/slack/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/slack/</guid>
      <description>In this example, we&amp;rsquo;ll walk through creating a Slack Slash Command service. The source for this is the SpartaSlackbot repo.
Our initial command handler won&amp;rsquo;t be very sophisticated, but will show the steps necessary to provision and configure a Sparta AWS Gateway-enabled Lambda function.
Define the Lambda Function This lambda handler is a bit more complicated than the other examples, primarily because of the Slack Integration requirements. The full source is:</description>
    </item>
    
    <item>
      <title>User Input</title>
      <link>/reference/apigateway/example2/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/example2/</guid>
      <description>This example demonstrates how to accept user input (delivered as HTTP query params) and return an expiring S3 URL to fetch content. The source for this is the s3ItemInfo function defined as part of the SpartaApplication.
Define the Lambda Function Our function will accept two params:
 bucketName : The S3 bucket name storing the asset keyName : The S3 item key  Those params will be passed as part of the URL query string.</description>
    </item>
    
    <item>
      <title>Workflow Hooks</title>
      <link>/reference/application/workflow_hooks/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/workflow_hooks/</guid>
      <description>Introduction While Sparta tries to provide workflows common across service lifecycles, it may be the case that an application requires additional functionality or runtime resources.
To support this, Sparta allows you to customize the build pipeline via WorkflowHooks structure. These hooks are called at specific points in the provision lifecycle and support augmenting the standard pipeline:
mermaid.initialize({startOnLoad:true}); graph TD classDef stdOp fill:#FFF,stroke:#A00,stroke-width:2px; classDef userHook fill:#B5B2A1,stroke:#A00,stroke-width:2px,stroke-dasharray: 5, 5; iam[Verify Static IAM Roles] class iam stdOp; preBuild[WorkflowHook - PreBuild] class preBuild userHook; compile[Cross Compile for AWS AMI] cgoCompile[CGO Docker Compile for AWS AMI] class compile,cgoCompile stdOp; postBuild[WorkflowHook - PostBuild] class postBuild userHook; nodeJSProxyShims[Create NodeJS-Go HTTP Proxies] pythonJSProxyShims[Create Python-CGO HTTP Proxies] package[ZIP archive] class nodeJSProxyShims,pythonJSProxyShims,package stdOp; userArchive[WorkflowHook - Archive] class userArchive userHook; upload[Upload Archive to S3] packageAssets[Conditionally ZIP S3 Site Assets] uploadAssets[Upload S3 Assets] class upload,packageAssets,uploadAssets stdOp; preMarshall[WorkflowHook - PreMarshall] class preMarshall userHook; generate[Marshal to CloudFormation] class generate stdOp; decorate[Call Lambda Decorators - Dynamic AWS Resources] class decorate stdOp; serviceDecorator[Service Decorator] class serviceDecorator userHook; postMarshall[WorkflowHook - PostMarshall] class postMarshall stdOp; uploadTemplate[Upload Template to S3] updateStack[Create/Update Stack] inplaceUpdates[In-place λ code updates] wait[Wait for Complete/Failure Result] class uploadTemplate,updateStack,inplaceUpdates,wait stdOp; iam--preBuild preBuild--|go|compile preBuild--|cgo|cgoCompile compile--postBuild cgoCompile--postBuild postBuild--|go|nodeJSProxyShims nodeJSProxyShims--package nodeJSProxyShims--packageAssets postBuild--|cgo|pythonJSProxyShims pythonJSProxyShims--package pythonJSProxyShims--packageAssets package--userArchive userArchive--upload packageAssets--uploadAssets uploadAssets--generate upload--generate generate--preMarshall preMarshall--decorate decorate--serviceDecorator serviceDecorator--postMarshall postMarshall--uploadTemplate uploadTemplate--|standard|updateStack uploadTemplate--|inplace|inplaceUpdates updateStack--wait  This diagram is rendered with Mermaid.</description>
    </item>
    
    <item>
      <title>CORS</title>
      <link>/reference/apigateway/cors/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/cors/</guid>
      <description>Cross Origin Resource Sharing defines a protocol by which resources on different domains may establish whether cross site operations are permissible.
Sparta makes CORS support a single CORSEnabled field of the API struct:
// Register the function with the API Gateway apiStage := sparta.NewStage(&amp;#34;v1&amp;#34;) apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaHTML&amp;#34;, apiStage) // Enable CORS s.t. the S3 site can access the resources apiGateway.CORSEnabled = true Setting the boolean to true will add the necessary OPTIONS and mock responses to all resources exposed by your API.</description>
    </item>
    
    <item>
      <title>Details</title>
      <link>/sample_service/step2/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/sample_service/step2/</guid>
      <description>The Overview walked through a simple &amp;ldquo;Hello World&amp;rdquo; example. In this section we&amp;rsquo;ll cover how Sparta works in preparation for moving on to more advanced use. Most development will use the provision command line argument, so this section will outline exactly what that entails.
Provisioning Flow The provisioning workflow is defined in provision.go, with a singular goal of encapsulating all AWS mutations into a CloudFormation template. Where CloudFormation does not support a given service, Sparta injects Lambda-backed Custom Resources into the template definition.</description>
    </item>
    
    <item>
      <title>S3 Sites with CORS</title>
      <link>/reference/s3site/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/s3site/</guid>
      <description>Sparta supports provisioning an S3-backed static website as part of provisioning. We&amp;rsquo;ll walk through provisioning a minimal Bootstrap website that accesses API Gateway lambda functions provisioned by a single service in this example.
The source for this is the SpartaHTML example application.
Create the Lambda function We&amp;rsquo;ll start by creating a very simple lambda function:
func helloWorld(w http.ResponseWriter, r *http.Request) { logger, _ := r.Context().Value(sparta.ContextKeyLogger).(*logrus.Logger) decoder := json.NewDecoder(r.Body) defer r.</description>
    </item>
    
    <item>
      <title>Presentations</title>
      <link>/reference/presentations/</link>
      <pubDate>Wed, 04 Oct 2017 22:12:35 +0000</pubDate>
      
      <guid>/reference/presentations/</guid>
      <description> Overview - October 2017 Image courtesy of Ashley McNamara </description>
    </item>
    
    <item>
      <title>CI/CD</title>
      <link>/reference/cicd/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/cicd/</guid>
      <description>Pending Document the SpartaCodePipeline example. Also see the Medium Post</description>
    </item>
    
    <item>
      <title>Step Functions</title>
      <link>/reference/step_functions/</link>
      <pubDate>Tue, 31 Oct 2017 18:20:05 +0000</pubDate>
      
      <guid>/reference/step_functions/</guid>
      <description>Introduction AWS Step Functions are a powerful way to express long-running, complex workflows comprised of Lambda functions. With Sparta 0.20.2, you can build a State Machine as part of your application. This section walks through the three steps necessary to provision a sample &amp;ldquo;Roll Die&amp;rdquo; state machine using a single Lambda function. See SpartaStep for the full source.
Lambda Functions The first step is to define the core Lambda function Task that will be our Step function&amp;rsquo;s core logic.</description>
    </item>
    
    <item>
      <title></title>
      <link>/_footer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/_footer/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>/_header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/_header/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>