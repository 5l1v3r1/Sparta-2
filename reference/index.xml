<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reference on Sparta - AWS Lambda Microservices</title>
    <link>/reference/</link>
    <description>Recent content in Reference on Sparta - AWS Lambda Microservices</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Mon, 22 Jan 2018 21:49:38 +0000</lastBuildDate>
    
	<atom:link href="/reference/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Service Custom Resources</title>
      <link>/reference/service_scoped_custom_resource/</link>
      <pubDate>Thu, 11 Oct 2018 07:57:40 +0000</pubDate>
      
      <guid>/reference/service_scoped_custom_resource/</guid>
      <description>TODO: See the CHANGES</description>
    </item>
    
    <item>
      <title>CI/CD</title>
      <link>/reference/cicd/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/cicd/</guid>
      <description>TODO
 CI/CD with Sparta Document the SpartaCodePipeline example. Also see the Medium Post</description>
    </item>
    
    <item>
      <title>CloudFormation Resources</title>
      <link>/reference/custom_lambda_resources/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/custom_lambda_resources/</guid>
      <description>Introduction In addition to per-lambda custom resources, a service may benefit from the ability to include a service-scoped Lambda backed CustomResource.
Including a custom service scoped resource is a multi-step process.
1. Resource Type The first step is to define a custom CloudFormation Resource Type
//////////////////////////////////////////////////////////////////////////////// // 1 - Define the custom type const spartaHelloWorldResourceType = &amp;#34;Custom::sparta::HelloWorldResource&amp;#34; 2. Request Parameters The next step is to define the parameters that are supplied to the custom resource invocation.</description>
    </item>
    
    <item>
      <title>Custom Resources</title>
      <link>/reference/custom_resources/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/custom_resources/</guid>
      <description>Introduction In some circumstances your service may need to provision or access resources that fall outside the standard workflow. In this case you can use CloudFormation Lambda-backed CustomResources to create or access resources during your CloudFormation stack&amp;rsquo;s lifecycle.
Sparta provides unchecked access to the CloudFormation resource lifecycle via the RequireCustomResource function. This function registers an AWS Lambda Function as an CloudFormation custom resource lifecycle.
In this section we&amp;rsquo;ll walk through a sample user-defined custom resource and discuss how a custom resource&amp;rsquo;s outputs can be propagated to an application-level Sparta lambda function.</description>
    </item>
    
    <item>
      <title>Deployment Strategies</title>
      <link>/reference/deployment_strategies/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/deployment_strategies/</guid>
      <description>TODO
 Deployment Strategies Document the SpartaSafeDeploy example.</description>
    </item>
    
    <item>
      <title>Discovery Service</title>
      <link>/reference/discovery/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/discovery/</guid>
      <description>Introduction The ability to provision dynamic infrastructure (see also the SES Event Source Example) as part of a Sparta application creates a need to discover those resources at lambda execution time.
Sparta exposes this functionality via sparta.Discover. This function returns information about the current stack (eg, name, region, ID) as well as metadata about the immediate dependencies of the calling go lambda function.
The following sections walk through provisioning a S3 bucket, declaring an explicit dependency on that resource, and then discovering the resource at lambda execution time.</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>/reference/docker/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/docker/</guid>
      <description>TODO
 Docker Support Document the SpartaDocker project.</description>
    </item>
    
    <item>
      <title>Dynamic Infrastructure</title>
      <link>/reference/dynamic_infrastructure/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/dynamic_infrastructure/</guid>
      <description>Introduction In addition to provisioning AWS Lambda functions, Sparta supports the creation of other CloudFormation Resources. This enables a service to move towards immutable infrastructure, where the service and its infrastructure requirements are treated as a logical unit.
For instance, consider the case where two developers are working in the same AWS account.
 Developer 1 is working on analyzing text documents.  Their lambda code is triggered in response to uploading sample text documents to S3.</description>
    </item>
    
    <item>
      <title>Hybrid Topologies</title>
      <link>/reference/hybrid_topologies/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/hybrid_topologies/</guid>
      <description>Introduction At a broad level, AWS Lambda represents a new level of compute abstraction for services. Developers don&amp;rsquo;t immediately concern themselves with HA topologies, configuration management, capacity planning, or many of the other areas traditionally handled by operations. These are handled by the vendor supplied execution environment.
However, Lambda is a relatively new technology and is not ideally suited to certain types of tasks. For example, given the current Lambda limits, the following task types might better be handled by &amp;ldquo;legacy&amp;rdquo; AWS services:</description>
    </item>
    
    <item>
      <title>Local Testing</title>
      <link>/reference/local_testing/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/local_testing/</guid>
      <description>While developing Sparta lambda functions it may be useful to test them locally without needing to provision each new code change. You can test your lambda functions using standard go test functionality.
To create proper event types, consider:
 AWS Lambda Go types Sparta types Use NewAPIGatewayMockRequest to generate API Gateway style requests.  </description>
    </item>
    
    <item>
      <title>Profiling</title>
      <link>/reference/profiling/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/profiling/</guid>
      <description>Introduction One of Lambda&amp;rsquo;s biggest strengths, its ability to automatically scale across ephemeral containers in response to increased load, also creates one of its biggest problems: observability. The traditional set of tools used to identify performance bottlenecks are no longer valid, as there is no host into which one can SSH and interactively interrogate. Identifying performance bottlenecks is even more significant due to the Lambda pricing model, where idle time often directly translates into increased costs.</description>
    </item>
    
    <item>
      <title>S3 Sites with CORS</title>
      <link>/reference/s3site/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/s3site/</guid>
      <description>Sparta supports provisioning an S3-backed static website as part of provisioning. We&amp;rsquo;ll walk through provisioning a minimal Bootstrap website that accesses API Gateway lambda functions provisioned by a single service in this example.
The source for this is the SpartaHTML example application.
Create the Lambda function We&amp;rsquo;ll start by creating a very simple lambda function:
import ( spartaAPIG &amp;#34;github.com/mweagle/Sparta/aws/apigateway&amp;#34; spartaAWSEvents &amp;#34;github.com/mweagle/Sparta/aws/events&amp;#34; ) type helloWorldResponse struct { Message string Request spartaAWSEvents.</description>
    </item>
    
    <item>
      <title>Step Functions</title>
      <link>/reference/step_functions/</link>
      <pubDate>Tue, 31 Oct 2017 18:20:05 +0000</pubDate>
      
      <guid>/reference/step_functions/</guid>
      <description>Introduction AWS Step Functions are a powerful way to express long-running, complex workflows comprised of Lambda functions. With Sparta 0.20.2, you can build a State Machine as part of your application. This section walks through the three steps necessary to provision a sample &amp;ldquo;Roll Die&amp;rdquo; state machine using a single Lambda function. See SpartaStep for the full source.
Lambda Functions The first step is to define the core Lambda function Task that will be our Step function&amp;rsquo;s core logic.</description>
    </item>
    
    <item>
      <title>Limitations</title>
      <link>/reference/limitations/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/limitations/</guid>
      <description> AWS Lambda Limitations  Lambda is not yet globally available. Please view the Global Infrastructure page for the latest deployment status. There are Lambda Limits that may affect your development It&amp;rsquo;s not possible to dynamically set HTTP response headers based on the Lambda response body:  https://forums.aws.amazon.com/thread.jspa?threadID=203889 https://forums.aws.amazon.com/thread.jspa?threadID=210826  Similarly, it&amp;rsquo;s not possible to set proper error response bodies.  </description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>/reference/faq/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/faq/</guid>
      <description>CloudFormation How do I create dynamic resource ARNs? Linking AWS resources together often requires creating dynamic ARN references. This can be achieved by using cloudformation.Join expressions.
For instance: import ( gocf &amp;#34;github.com/mweagle/go-cloudformation&amp;#34; ) s3SiteBucketAllKeysResourceValue := gocf.Join(&amp;#34;&amp;#34;, gocf.String(&amp;#34;arn:aws:s3:::&amp;#34;), gocf.Ref(s3BucketResourceName), gocf.String(&amp;#34;/*&amp;#34;))
import ( gocf &amp;#34;github.com/mweagle/go-cloudformation&amp;#34; ) AuthorizerURI: gocf.Join(&amp;#34;&amp;#34;, gocf.String(&amp;#34;arn:aws:apigateway:&amp;#34;), gocf.Ref(&amp;#34;AWS::Region&amp;#34;).String(), gocf.String(&amp;#34;:lambda:path/2015-03-31/functions/&amp;#34;), gocf.GetAtt(myAWSLambdaInfo.LogicalResourceName(), &amp;#34;Arn&amp;#34;), gocf.String(&amp;#34;/invocations&amp;#34;)), See the CloudFormation Fn::GetAtt docs for the set of attributes created by each resource. CloudFormation pseudo-paramters can be included in dynamic expresssions via gocf.</description>
    </item>
    
  </channel>
</rss>