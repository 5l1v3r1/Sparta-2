+++
author = "Matt Weagle"
date = "2015-11-29T06:50:17"
title = "Walkthrough"
tags = ["sparta"]
type = "doc"
+++

The [Overview](/docs/overview) walked through a simple "Hello World" example.  In this section we'll cover how Sparta works in preparation for moving on to more advanced usages.  Most development will use the `provision` command line argument, so this section will outline exactly what that entails.

### <a href="{{< relref "#provisioningFlow" >}}">Provisioning Flow</a>

The provisioning workflow is defined in [provision.go](https://github.com/mweagle/Sparta/blob/master/provision.go), with a singular goal of encapsulating all AWS mutations into a [CloudFormation](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html) template.  Where CloudFormation does not support a given service, Sparta injects [Lambda-backed Custom Resources](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources-lambda.html) into the template definition.

At a high level, provisioning uses the flow below.  We'll dive a bit deeper into each stage in the following sections.

{{< mermaid >}}
    graph TD
      iam[Verify IAM Roles]
      compile[Compile]
      package[Package]
      upload[Upload Archive to S3]
      generate[Generate CF Template]
      uploadTemplate[Upload Template to S3]
      converge[Create/Update Stack]

      iam-->compile
      compile-->package
      package-->upload
      upload-->generate
      generate-->uploadTemplate
      uploadTemplate-->converge
{{< /mermaid >}}

### <a href="{{< relref "#verifyiamroles" >}}">Verify IAM Roles</a>
The `NewLambda` function accepts either a `string` or a `sparta.IAMRoleDefinition` value type.  In the event that a string is passed, this function verifies that the IAM role exists and builds up a cache of IAM role information that can be shared and referenced during template generation. Specifically, a pre-existing [IAM Role ARN](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns) is cached to minimize AWS calls during template generation.

### <a href="{{< relref "#compile" >}}">Compile</a>
The next step is to cross compile the application to a binary that can be executed on an AWS Lambda instance.  The compile flags are:

  * **TAGS**:         `-tags lambdabinary`
  * **ENVIRONMENT**:  `GOOS=linux GOARCH=amd64 GO15VENDOREXPERIMENT=1`

The binary is built in the current directory with a _.lambda.amd64_ suffix.  

### <a href="{{< relref "#package" >}}">Package</a>

The end result of the package phase is a ZIP archive containing everything needed to deploy your service.
This includes the NodeJS proxy entries that forward AWS Lambda requests to your **Go** binary HTTP-based handler.  The packaging step also includes NodeJS code to support CloudFormation custom resources for services such as
API Gateway configuration and S3 push source configuration.  Finally, a known version of the AWS SDK is included (that's the _node_modules_ copying you'll see if you enable `debug` verbosity) that's likely newer than the one included in the [AWS Lambda runtime](https://aws.amazon.com/releasenotes/AWS-Lambda).

Over time it's expected that CloudFormation grows to support additional services and capabilities, at which point much of the NodeJS code can be eliminated.  

Everything is ZIP'd up and ready for S3 upload.

### <a href="{{< relref "#uploadArchiveToS3" >}}">Upload Archive To S3</a>

Uploads the archive to S3.  There's not much else to see here.

### <a href="{{< relref "#generateCFTemplate" >}}">Generate CloudFormation Template</a>

Once the archive is uploaded and the S3 Item key is available, the  CloudFormation template is generated by marshaling the `sparta.LambdaAWSInfo` objects into CloudFormation JSON representations.

The AWS Lambda marshaling is automatically handled.  This is also the point at which the optional [TemplateDecorator](https://github.com/mweagle/Sparta/blob/master/sparta.go#L192) functions are called to annotate the automatically generated template with additional resources.

### <a href="{{< relref "#uploadCFTemplate" >}}">Upload CloudFormation Template to S3</a>

Uploads the template to S3 to maximize [template size](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html).  There's not much else to see here.

### <a href="{{< relref "#createUpdateStack" >}}">Create/Update Stack</a>

Finally, the provisioning workflow determines whether the Sparta `serviceName` exists and either creates or updates as appropriate.

## Next Steps

Now that we've covered how Sparta handles provisioning your stack, we're ready to expand functionality to leverge more of the AWS ecosystem in the [next section](/docs/eventsources/).
