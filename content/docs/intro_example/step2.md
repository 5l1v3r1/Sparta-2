---
date: 2016-03-09T19:56:50+01:00
title: Sample Service - Details
weight: 20
---

The [Overview](/docs/intro_example/step1) walked through a simple "Hello World" example.  In this section we'll cover how Sparta works in preparation for moving on to more advanced use.  Most development will use the `provision` command line argument, so this section will outline exactly what that entails.

# Provisioning Flow

The provisioning workflow is defined in [provision.go](https://github.com/mweagle/Sparta/blob/master/provision.go), with a singular goal of encapsulating all AWS mutations into a [CloudFormation](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html) template.  Where CloudFormation does not support a given service, Sparta injects [Lambda-backed Custom Resources](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources-lambda.html) into the template definition.

At a high level, provisioning uses the flow below.  We'll dive a bit deeper into each stage in the following sections.

{{< spartaflow >}}

## Verify Static IAM Roles
The `HandleAWSLambda` function accepts either a `string` or a `sparta.IAMRoleDefinition` value type.  In the event that a string is passed, this function verifies that the IAM role exists and builds up a cache of IAM role information that can be shared and referenced during template generation. Specifically, a pre-existing [IAM Role ARN](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns) is cached to minimize AWS calls during template generation.

## Compile
The next step is to cross compile the application to a binary that can be executed on an AWS Lambda instance.  The compile flags are:

  * **TAGS**:         `-tags lambdabinary`
  * **ENVIRONMENT**:  `GOOS=linux GOARCH=amd64`

The binary is built in the current directory with a _.lambda.amd64_ suffix.

## Package

The end result of the package phase is a ZIP archive containing everything needed to deploy your service.
This includes the NodeJS proxy entries that forward AWS Lambda requests to your **go** binary HTTP-based handler. It also includes core [google-protobuf](https://www.npmjs.com/package/google-protobuf) to handle de/serializing events to your application. You can see these additional resources being included if you enable `--level debug` verbosity on the command line.


## Upload Archive To S3

Uploads the archive to S3.  There's not much else to see here.

## Generate CloudFormation Template

Once the archive is uploaded and the S3 Item key is available, the  CloudFormation template is generated by marshaling the `sparta.LambdaAWSInfo` objects into CloudFormation JSON representations.

The AWS Lambda marshaling is automatically handled.  This is also the point at which the optional [TemplateDecorator](https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator) functions are called to annocate the automatically generated template with additional resources.

## Upload CloudFormation Template to S3

Uploads the template to S3 to maximize [template size](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html).  There's not much else to see here.

## Create/Update Stack

Finally, the provisioning workflow determines whether the Sparta `serviceName` exists and either creates or updates as appropriate.

# Next Steps

Now that we've covered how Sparta handles provisioning your stack, we're ready to expand functionality to leverge more of the AWS ecosystem in the [next section](/docs/eventsources/eventsources/).
